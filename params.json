{"name":"Harbor","tagline":"Harbor is a set of tools and services for microservice deployment.","body":"harbor\r\n======\r\n\r\nHarbor is a routing layer and set of deployment tools for\r\n[12factor](http://12factor.net) microservice infrastructures. It allows\r\nengineering teams to easily deploy releases onto production infrastructure\r\nwithout downtime, and cut traffic over to individual services at their leisure.\r\n\r\nIt's designed to be modular and pluggable - if you want to run your own PaaS,\r\nharbor will do that. If you want to run your services on Heroku, harbor\r\nwill help with the coordination of that as well.\r\n\r\nIn short, as an engineer, it makes life as simple as this;\r\n\r\n```bash\r\nadrian$ harbor deploy\r\n# Harbor firing a deploy for \"Thunderchicken\"\r\n# - Thunderchicken#backend-service-1 has new revision, spawning on prod-1.foobarapp.com\r\n# - Thunderchicken#backend-service-1#c211f listening on port 4921\r\n# - New build `020864f02d7c4c832aca7d204ca9b9cd59934287` released\r\nadrian$ harbor route production 020864f02d7c4c832aca7d204ca9b9cd59934287\r\n# Harbor routing production traffic to 020864f02d7c4c832aca7d204ca9b9cd59934287\r\n# - Thunderchicken#backend-service-1#a3321 is orphaned and can reaped from all hosts.\r\n```\r\n\r\nA lot just happened - I committed some changes to `backend-service-1`, and\r\nreleased a new build of our entire app. Anything other than `backend-service-1`\r\nwas untouched, and no traffic touched the new revision until I asked to move\r\ntraffic over.\r\n\r\nIf you want to jump right in, install the [harbor_cli](http://adrianpike.github.com/harbor-cli)\r\ngem, and run `harbor init`. It'll walk you through what you need.\r\n\r\nUnder the hood, here's what's happening;\r\n\r\n - I requested a deploy, and a Harborfile was read, to determine\r\n   all the services that make up this app and understand a little about my\r\n   deployment environment.\r\n - My local Git SHAs were compared against running SHAs across the entire\r\n   collection of Harbor servers.\r\n - A new SHA was discovered, a Harbor server was selected to deploy to, and a\r\n   new process was spawned on that server running the newest code for that\r\n   service.\r\n - Any DNS references to internal services were updated to point to the correct\r\n   revisions in the code I just deployed for `backend-service-1`.\r\n - A `build` was determined, which is a collection of service SHAs to consider\r\n   as one running build.\r\n - All the build, service, and revision hosts, ports and SHAs were updated in\r\n   our port registry.\r\n - I flipped production traffic over to that latest `build`, and traffic began\r\n   to flow to the new revision of `backend-service-1`, and since I didn't bump\r\n   any other services, everything else remained.\r\n\r\nQuickstart\r\n----------\r\n\r\n```blockquote\r\nPlease note, as of March 3rd, 2015, Harbor is under active development and\r\nshould be used with care. Things will be shifting around underneath you in\r\nthe next few weeks, it's untested.\r\n\r\nWith that said, it _is_ currently handling production traffic for a handful\r\nof sites.\r\n```\r\n\r\nThere's some important assumptions we'll make out of the gate.\r\n\r\n - You're using git as your VCS. There are no plans at this time to support others.\r\n - You've got more than one service. Otherwise, just use Heroku, life will be easier!\r\n - You're using HTTP to communicate between services.\r\n - Services listen on a $PORT environment variable, and we've decided on some\r\n   unique ports to use for inter-service communication and development.\r\n\r\n```\r\nAs of March 2nd, 2015 the only way to host apps is through the native harbord.\r\nThe next hosting layer to be supported is Heroku.\r\n```\r\n\r\n### harbord Setup\r\n\r\n1) Clone [harbor](http://github.com/adrianpike/harbor) (this repo) somewhere\r\non the server(s) you want to deploy to.\r\n\r\n2) `npm install`\r\n\r\n3) Edit `etc/config.json` to point to a shared Redis instance for persistent\r\nstorage.\r\n\r\n4) Run `bin/harbord`\r\n\r\n5) Ensure your control port (default 6060) is closed off to public traffic.\r\nThe Harbor CLI uses SSH tunneling for its access.\r\n\r\n### Client Setup\r\n\r\n1) Install [harbor_cli](http://github.com/adrianpike/harbor_cli). Then come back here.\r\n\r\n2) Initialize your Harborfile with `harbor init`. Follow the prompts.\r\n\r\n```bash\r\nadrian$ cd src/my_amazing_project/\r\nadrian$ harbor init\r\nStarting Harborfile generated from your Procfile. You should review and edit it.\r\n##### Finishing Up #####\r\n1. Any places where you're referencing external services need to be changed to\r\n   the .harbor suffix. Please see http://adrianpike.github.io/harbor/ for more\r\n   information.\r\n2. You need to set up local DNS to resolve .harbor to 127.0.0.1.\r\n3. Use Foreman as usual.\r\n```\r\n\r\n3) Ensure you're set up for passwordless SSH to any hosts you want to deploy to.\r\n\r\nYou're ready to go! If you want to dive in, start playing with the Harbor CLI.\r\nIf you want to learn more about what's happening, read on.\r\n\r\nAbout Harbor\r\n------------\r\n\r\n### A Service\r\n\r\nA Service is a single [12factor](http://12factor.net) service which is a component of a larger\r\napplication. Services are given dynamic ports via the PORT environment variable.\r\nA service listens on this port for HTTP traffic, and has traffic routed to it\r\nvia the `Routing Layer`.\r\n\r\n### The build step\r\n\r\n```\r\nThe build process is within the CLI, and is currently in flux to move to Heroku\r\nbuildpacks.\r\n```\r\n\r\n### The Routing Layer\r\n\r\nThe routing layer is how HTTP traffic is routed to the correct instance of a\r\nservice. The lifecycle of an HTTP request can be complicated as it moves\r\nthrough the appropriate versioning systems.\r\n\r\n - TCP Port - [Service] -> Service Name\r\n - Domain - [Route] -> Deploy/Release SHA\r\n - Deploy/Release SHA - [Deploy] -> Service SHA\r\n - Service SHA - [Port Registry] -> Instance\r\n\r\n### Service Versioning\r\n\r\n```\r\nService versioning is currently in flux.\r\n```\r\n\r\n### The Harborfile\r\n\r\nThe Harborfile is how the CLI is configured. It specifies what your services\r\nare, where they can be found locally, what deploy method(s) you're using, and\r\nanything else that might need to be configured. You shouldn't be creating your\r\nHarborfile from scratch though - the CLI has the `harbor init` command to walk\r\nyou through it and auto-discover what it can.\r\n\r\nAn example is below;\r\n\r\n```yaml\r\nservices:\r\n  web:\r\n    port: 80\r\n    cmd: bundle exec unicorn -p $PORT -c ./config/unicorn.rb\r\n    path: ./\r\n  cuckoo:\r\n    port: 6060\r\n    cmd: supervisor -w cuckoo -- ./cuckoo/cuckoo.coffee\r\n    path: ../cuckoo\r\n  arterial:\r\n    port: 5252\r\n    cmd: supervisor -w arterial -- ./arterial/lib/server.coffee\r\n    path: ../arterial\r\nharbor:\r\n  app: elapse\r\n  deploy_dir: '/home/apps/deploys'\r\n  deploy_user: apps\r\n  servers:\r\n    - type: http+ssh\r\n      host: sea1.adrianpike.com\r\n```\r\n\r\n\r\nImmediate TODO\r\n--------------\r\n\r\nPrerelease\r\n- Use Heroku buildpacks correctly in the CLI\r\n- Development mode\r\n- Persistent services\r\n\r\n- Harbord namespaced per application (v0)\r\n\r\n- Backend hosting layers\r\n  - Heroku (v1)\r\n  - Native method (v0)\r\n\r\n- Routing layers\r\n  - Native (v1)\r\n  - Direct DNS (icebox)\r\n  - offload to a haproxy (v2)\r\n\r\n- Inter-process routing method\r\n  - Multiple instances of Upstream services (v2)\r\n  - Header passing through magic (v1)\r\n\r\n- Persistence Backend layers\r\n  - Redis (v1)\r\n  - etcd (v2)\r\n  - consul (v2)\r\n\r\n- Logging layers\r\n  - capture to files (v1)\r\n\r\n- Metrics layers (v2)\r\n  - statsd\r\n  - stdout\r\n  - graphite\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}